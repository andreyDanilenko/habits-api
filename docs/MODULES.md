# Модули системы: идентичность, привязка, фронтенд

## Где у модуля появляется ID и как он привязывается

### Backend

1. **Справочник модулей** — таблица `modules`:
   - `id` (UUID) — внутренний ключ;
   - `code` (уникальный) — **это и есть идентификатор модуля** (`habits`, `crm`, …).
2. **Момент создания**: при миграции в сид вставляются строки (см. `000012_create_modules_and_workspace_modules.up.sql`):
   ```sql
   INSERT INTO modules (id, code, name, description, is_core) VALUES
     (..., 'habits', 'Привычки', ...),
     (..., 'crm', 'CRM', ...);
   ```
3. **Привязка к workspace** — таблица `workspace_modules`:
   - `workspace_id` + `module_id` (FK в `modules`);
   - `status` (`active` / `trial` / `disabled`).
   - Ответ на вопрос «какие модули включены в этом workspace» даёт запрос к `workspace_modules` по `workspace_id` (с join с `modules` для получения `code`).

**Как добавить новый модуль на бэкенде:**

- Добавить запись в `modules` (миграция или сид): новый `code`, например `inventory`.
- Создать свои таблицы сущностей модуля (все с `workspace_id`), например `crm_contacts`, `crm_deals`.
- Никакой явной привязки сущностей к `module_id` не обязательно: принадлежность к модулю задаётся конвенцией (все таблицы с префиксом/доменом и `workspace_id`).

---

### Frontend

1. **Статический конфиг** — `src/app/modules/config.ts`:
   - Массив `modules`: у каждого элемента поле **`id`** — строка, которая **должна совпадать с `code`** из бэкенда (`habits`, `crm`).
   - Там же: `basePath`, `routes` (path, name, component), иконки, права.
2. **Откуда фронт узнаёт «приходящий модуль»**:
   - Запрос `GET /api/v1/workspaces/:id/modules` возвращает список включённых модулей для текущего workspace.
   - В ответе у каждого модуля есть поле **`moduleName`** — это и есть `code` с бэкенда (`habits`, `crm`).
   - В сторе по этому ответу формируется список кодов: `enabledModules` (массив строк).
3. **Как фронт сопоставляет модуль и роуты**:
   - В конфиге у каждого модуля `module.id` совпадает с `moduleName` (code) из API.
   - Доступные модули для меню/сайдбара: `getAvailableModules(enabledModuleCodes, hasPermission)` — фильтр по `enabledModuleCodes.includes(module.id)` и правам.
   - Роуты уже зарегистрированы для всех модулей из конфига; при заходе на роут срабатывает guard `requireModuleEnabled`, который проверяет `to.meta.module` (это `module.id`) по списку `workspaceStore.enabledModules`. Если модуль не включён в workspace — редирект.

Итого: **модуль идентифицируется строкой-кодом** (`code` в БД = `id` в конфиге = `moduleName` в ответе API). По этой строке бэкенд отдаёт «включён/выключен», фронт решает, показывать ли модуль и разрешать ли роут.

---

## Что «входит в состав» модуля

- **Backend**: все сущности (таблицы, хендлеры, сервисы), которые относятся к одному домену и привязаны к `workspace_id`. Имя модуля задаётся конвенцией (например, таблицы `crm_*`, пакет `crm`).
- **Frontend**: один объект в массиве `modules` в конфиге с этим `id` и его `routes` (path → component). Все страницы, лежащие по `basePath` модуля и перечисленные в `routes`, считаются частью модуля.

---

## Добавление нового модуля (чеклист)

### Backend

1. Добавить запись в `modules` (миграция), например `code = 'crm'`.
2. Создать миграции таблиц (все с `workspace_id`).
3. Модели, репозиторий, сервис, хендлер по домену.
4. При необходимости включить модуль в workspace по умолчанию через `workspace_modules` (или оставить выборочное включение).

### Frontend

1. В `app/modules/config.ts` добавить объект в массив `modules` с **`id` = `code`** из БД.
2. Задать `basePath`, `routes` (path, name, component, permissions).
3. Создать страницы (компоненты) для каждого роута.
4. Роутер подхватит новые роуты из конфига; guard проверит доступ по `enabledModules` и правам.

---

## Админ: отдельный доступ

Эндпоинты с префиксом `/api/v1/admin/*` защищены middleware `RequireAdmin`: только пользователи с глобальной ролью `ADMIN` (поле `users.role`) получают доступ. Остальные, даже с валидным токеном, получают **403 Forbidden**.

- **GET /api/v1/admin/workspaces** — список всех workspaces (только для ADMIN). Используется для переключения админа в любой workspace.
- **POST /api/v1/admin/users/:id/licenses** — выдать лицензию пользователю на модуль (body: `moduleCode`, `scope` = `all_workspaces` | `single_workspace`, опционально `workspaceId` для single_workspace). До момента оплаты — способ дать доступ.
- **GET /api/v1/workspaces/me/module-licenses** — список активных лицензий текущего пользователя (для UI: какие модули можно включать).

---

## Логика активации модуля (как сейчас работает)

### Кто может включить модуль в workspace

- **Владелец workspace** (пользователь, создавший workspace, `workspaces.owner_id`) может вызывать `POST /api/v1/workspaces/:id/modules` с телом `{ "moduleCode": "crm" }`.
- **Глобальный админ** (`users.role = ADMIN`) может то же самое для любого workspace.
- Обычный участник workspace (member) **не может** включить модуль через API — получит **403 Forbidden**.

### Цепочка на бэкенде

1. **POST /workspaces/:id/modules** → handler `EnableModule`.
2. Проверка прав: если роль не `ADMIN`, проверяется `IsOwner(workspaceID, userID)` по таблице `workspaces`. Иначе — `ErrAccessDenied`.
3. По `moduleCode` ищется запись в справочнике `modules` (`GetModuleByCode`). Если модуля нет — `ErrModuleNotFound`.
4. **Проверка лицензии** (для не-админа и не-core модуля): у владельца воркспейса должна быть активная запись в `user_module_licenses` с `scope = all_workspaces` или `scope = single_workspace` и `workspace_id = текущий воркспейс`. Иначе — `ErrLicenseRequired` (403).
5. В таблицу `workspace_modules` делается `INSERT ... ON CONFLICT DO UPDATE SET status = 'active'`. Отключение модуля — только смена `status` на `disabled` в `workspace_modules`; лицензия у пользователя не удаляется (можно снова включить без покупки).

### Фронтенд

- Страница **«Модули»** (`/workspace-modules`): список доступных (уже включённых) и недоступных модулей из конфига.
- Для **недоступных** модулей:
  - **Владелец или админ** видит кнопку **«Активировать»** → вызов `enableModule(workspaceId, moduleCode)` → перезагрузка списка модулей workspace.
  - **Обычный пользователь** не может включить модуль сам; ему предлагается переход на страницу покупки/связи с владельцем приложения (заглушка), чтобы оформить подписку или вечную лицензию — фактическая активация в workspace по-прежнему выполняется владельцем/админом или после интеграции с платёжкой.
- Активация «здесь и сейчас» — только через кнопку «Активировать» для owner/admin. Модель подписки или вечного пользования тестируется на странице покупки (заглушка), без изменения этой логики.

### Потенциальная активация для обычного пользователя (архитектура)

- Обычный пользователь не может вызывать `POST .../modules` — права не меняются.
- Ему показывается кнопка **«Перейти к покупке / связь с владельцем»** → переход на страницу **`/module-activation/:moduleCode`** (заглушка).
- На этой странице: пометка для владельца приложения, заглушки «Подписка» и «Вечная лицензия» для тестирования модели. Фактическое включение модуля в workspace по-прежнему делается только через API владельцем/админом (или в будущем — по вебхуку после оплаты).
- Так сохраняется чистота архитектуры: слой прав (кто может включить модуль) не смешивается с UX (покупка/запрос активации). Интеграция платёжки или «связаться с владельцем» живёт на отдельной странице и не обходит проверки бэкенда.

---

## Деактивация модуля и управление

### Кто может отключить модуль

- **Владелец workspace** и **глобальный админ** могут отключить модуль в workspace.
- **Обычный участник (member) не может** отключать модули — кнопки «Отключить» у него нет. Таким образом, оплаченный модуль не может быть случайно отключён рядовым пользователем.

### API

- **DELETE** ` /api/v1/workspaces/:id/modules/:moduleCode` — переводит запись в `workspace_modules` в статус `disabled`. Разрешено только владельцу воркспейса или глобальному админу. Тело не требуется.

### Как админ может отключить модуль у пользователя

1. Войти под учётной записью с ролью **ADMIN**.
2. В админ-панели переключиться на нужный workspace (или попросить владельца отключить модуль в настройках своего workspace).
3. Открыть **Настройки воркспейса** → ссылка **«Перейти к списку модулей»** (или напрямую `/workspace-modules` при выбранном этом workspace).
4. В блоке «Доступные модули» нажать **«Отключить»** у нужного модуля и подтвердить в диалоге.

### Быстрое исправление, если пользователь случайно включил модуль

**Вариант 1 — через UI (рекомендуется):**  
Владелец workspace или админ заходит в Настройки воркспейса → список модулей → для лишнего модуля нажимает «Отключить» и подтверждает.

**Вариант 2 — через API (curl):**  
От имени владельца воркспейса или админа выполнить:
```bash
curl -X DELETE "https://<host>/api/v1/workspaces/<workspace_id>/modules/<module_code>" \
  -H "Authorization: Bearer <token>"
```
Пример: отключить CRM в workspace `abc-123`: `DELETE .../workspaces/abc-123/modules/crm`.

**Вариант 3 — напрямую в БД (если нет доступа к UI/API):**  
```sql
UPDATE workspace_modules
SET status = 'disabled'
WHERE workspace_id = '<workspace_uuid>'
  AND module_id = (SELECT id FROM modules WHERE code = 'crm');
```
После этого перезагрузить страницу «Модули» у пользователя (или повторно запросить `GET .../workspaces/:id/modules`) — модуль будет в списке недоступных.

### Включить обратно отключённый модуль

- Через UI: на странице «Модули» в блоке «Недоступные модули» нажать **«Активировать»** (владелец/админ).
- Через API: `POST /api/v1/workspaces/:id/modules` с телом `{ "moduleCode": "crm" }` (от владельца или админа).
