# Простая система логирования

## Как работает

1. **Каждый запрос** → сразу записывается в файл `logs/requests-YYYY-MM-DD.log`
2. **Раз в сутки в полночь** → вчерашний файл синхронизируется в БД

## Структура кода

### 1. Middleware (`internal/middleware/request_logger.go`)
- Перехватывает каждый HTTP запрос
- Форматирует строку лога
- Сразу записывает в файл (синхронно)

### 2. Service (`internal/service/logger/service.go`)
- `WriteLog()` - записывает строку в файл
- `SyncToDB()` - читает вчерашний файл и записывает в БД

### 3. Repository (`internal/repository/logger/repository.go`)
- `BatchInsert()` - записывает логи в БД

### 4. Worker (`internal/worker/log_processor.go`)
- Запускается раз в сутки в полночь
- Вызывает `SyncToDB()` для синхронизации

## Пример лог-файла

```
[GIN] 2026/01/15 - 13:46:31 | 404 |      12.875µs |             ::1 | GET      "/"
[GIN] 2026/01/15 - 13:47:00 | 200 |     4.83725ms |             ::1 | GET      "/health"
[GIN] 2026/01/15 - 13:47:17 | 200 |    1.683708ms |             ::1 | GET      "/habits"
```

## Настройка

В `.env`:
```env
LOGS_DIR=./logs
```

## Что происходит

1. Запрос приходит → middleware записывает в файл сразу
2. В полночь → worker читает файл за вчера и пишет в БД
3. Файлы остаются на диске для истории

## API для работы с логами

### Получить логи из БД

```bash
# Получить логи за вчерашний день (по умолчанию)
GET /logs

# Получить логи за конкретную дату
GET /logs?date=2026-01-15
```

**Ответ:**
```json
{
  "date": "2026-01-15",
  "count": 10,
  "logs": [
    {
      "timestamp": "2026-01-15T13:47:00Z",
      "status_code": 200,
      "duration": "4.83725ms",
      "client_ip": "::1",
      "method": "GET",
      "path": "/health",
      "raw_log": "[GIN] 2026/01/15 - 13:47:00 | 200 | 4.83725ms | ::1 | GET      /health"
    }
  ]
}
```

### Синхронизировать логи вручную

```bash
POST /logs/sync
```

**Ответ:**
```json
{
  "message": "logs synchronized successfully"
}
```

Синхронизирует вчерашний лог-файл в БД (то же самое, что делает worker в полночь).
